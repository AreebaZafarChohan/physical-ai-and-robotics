"use strict";(self.webpackChunkphysical_ai_and_robotics=self.webpackChunkphysical_ai_and_robotics||[]).push([[573],{5172:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"module-digital-twin/gazebo-setup","title":"Gazebo Setup for Digital Twin","description":"In the development of complex robotic systems, especially humanoids, a crucial step involves leveraging digital twins. A digital twin is a virtual representation of a physical object or system, allowing for testing, analysis, and optimization in a simulated environment before deployment in the real world. For robotics, Gazebo stands out as a powerful and widely used 3D physics simulator that provides a robust platform for creating and interacting with these digital twins.","source":"@site/docs/02-module-digital-twin/01-gazebo-setup.md","sourceDirName":"02-module-digital-twin","slug":"/module-digital-twin/gazebo-setup","permalink":"/ur/docs/module-digital-twin/gazebo-setup","draft":false,"unlisted":false,"editUrl":"https://github.com/AreebaZafarChohan/physical-ai-and-robotics/tree/main/frontend/docs/02-module-digital-twin/01-gazebo-setup.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Gazebo Setup for Digital Twin"},"sidebar":"tutorialSidebar","previous":{"title":"Try with AI: \\"URDF for Humanoids\\"","permalink":"/ur/docs/module-ros/try-with-ai/ai-urdf-for-humanoids"},"next":{"title":"Physics Simulation in Gazebo","permalink":"/ur/docs/module-digital-twin/physics-simulation"}}');var t=i(4848),s=i(8453);const a={title:"Gazebo Setup for Digital Twin"},r="Gazebo Setup for Digital Twin",l={},d=[{value:"What is Gazebo?",id:"what-is-gazebo",level:2},{value:"Setting Up Gazebo with ROS 2",id:"setting-up-gazebo-with-ros-2",level:2},{value:"1. Installation",id:"1-installation",level:3},{value:"2. Creating a Simple World File",id:"2-creating-a-simple-world-file",level:3},{value:"3. Spawning a Robot Model in Gazebo",id:"3-spawning-a-robot-model-in-gazebo",level:3},{value:"Running the Simulation",id:"running-the-simulation",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"gazebo-setup-for-digital-twin",children:"Gazebo Setup for Digital Twin"})}),"\n",(0,t.jsxs)(n.p,{children:["In the development of complex robotic systems, especially humanoids, a crucial step involves leveraging ",(0,t.jsx)(n.strong,{children:"digital twins"}),". A digital twin is a virtual representation of a physical object or system, allowing for testing, analysis, and optimization in a simulated environment before deployment in the real world. For robotics, ",(0,t.jsx)(n.strong,{children:"Gazebo"})," stands out as a powerful and widely used 3D physics simulator that provides a robust platform for creating and interacting with these digital twins."]}),"\n",(0,t.jsx)(n.h2,{id:"what-is-gazebo",children:"What is Gazebo?"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo is an open-source 3D robotics simulator that allows you to accurately and efficiently simulate populations of robots in complex indoor and outdoor environments. It offers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Powerful Physics Engine"}),": Gazebo uses physics engines like ODE, Bullet, Simbody, and DART to accurately simulate dynamics, gravity, friction, and collisions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"High-Quality Graphics"}),": Renders realistic environments and robot models."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sensor Simulation"}),": Simulates a wide range of sensors (cameras, LIDAR, IMU, sonar, force-torque sensors) with realistic noise and data output."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plugins"}),": A flexible plugin architecture allows users to extend its functionality, integrate with external software (like ROS 2), and customize robot behaviors."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Command-Line and GUI Interface"}),": Can be run headlessly for automated testing or with a graphical interface for interactive development."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Gazebo's ability to create a high-fidelity virtual replica of a robot and its environment makes it an indispensable tool for developing and testing complex AI and control algorithms for humanoids."}),"\n",(0,t.jsx)(n.h2,{id:"setting-up-gazebo-with-ros-2",children:"Setting Up Gazebo with ROS 2"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo integrates seamlessly with ROS 2, leveraging ROS 2's communication infrastructure to control robots and read sensor data within the simulation."}),"\n",(0,t.jsx)(n.h3,{id:"1-installation",children:"1. Installation"}),"\n",(0,t.jsx)(n.p,{children:"If you've installed a full ROS 2 distribution, Gazebo (usually Gazebo Garden or Harmonic, depending on your ROS 2 distro) is often included. If not, you can install it:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# For Ubuntu 22.04 and ROS 2 Jazzy (or similar distros)\nsudo apt update\nsudo apt install ros-jazzy-gazebo-ros-pkgs ros-jazzy-gazebo-ros2-control\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This typically installs Gazebo and the necessary ROS 2 bridge packages (",(0,t.jsx)(n.code,{children:"gazebo_ros_pkgs"})," and ",(0,t.jsx)(n.code,{children:"gazebo_ros2_control"}),") which facilitate communication between Gazebo and ROS 2 nodes."]}),"\n",(0,t.jsx)(n.h3,{id:"2-creating-a-simple-world-file",children:"2. Creating a Simple World File"}),"\n",(0,t.jsxs)(n.p,{children:["A Gazebo ",(0,t.jsx)(n.strong,{children:"world file"})," (typically ",(0,t.jsx)(n.code,{children:".world"})," extension) defines the environment, including static objects, light sources, and initial robot spawn positions. It's an XML file."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Example: ",(0,t.jsx)(n.code,{children:"my_empty_world.world"})]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.6">\n  <world name="my_empty_world">\n    <include>\n      <uri>model://sun</uri>\n    </include>\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n    \x3c!-- You can add more static models here --\x3e\n    \x3c!-- <include>\n      <uri>model://brick_box_3x1x3</uri>\n      <pose>0 2 0.5 0 0 0</pose>\n    </include> --\x3e\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["You can place this in a ",(0,t.jsx)(n.code,{children:"worlds"})," directory within your ROS 2 package (e.g., ",(0,t.jsx)(n.code,{children:"my_robot_simulation/worlds/"}),")."]}),"\n",(0,t.jsx)(n.h3,{id:"3-spawning-a-robot-model-in-gazebo",children:"3. Spawning a Robot Model in Gazebo"}),"\n",(0,t.jsx)(n.p,{children:"To spawn a robot, you need its URDF (or SDF) model and a ROS 2 launch file to orchestrate the process."}),"\n",(0,t.jsxs)(n.p,{children:["Let's assume you have a URDF file for a simple robot (e.g., ",(0,t.jsx)(n.code,{children:"my_simple_robot.urdf"})," in ",(0,t.jsx)(n.code,{children:"my_robot_description/urdf/"}),")."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Launch File Example (",(0,t.jsx)(n.code,{children:"spawn_robot.launch.py"}),")"]})}),"\n",(0,t.jsx)(n.p,{children:"This launch file will:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Load the robot's URDF description."}),"\n",(0,t.jsx)(n.li,{children:"Start Gazebo with your custom world."}),"\n",(0,t.jsx)(n.li,{children:"Spawn your robot model into the Gazebo world."}),"\n",(0,t.jsxs)(n.li,{children:["Launch ",(0,t.jsx)(n.code,{children:"robot_state_publisher"})," and ",(0,t.jsx)(n.code,{children:"joint_state_publisher_gui"})," (as discussed in the URDF chapter)."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription, DeclareLaunchArgument\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    # Path to your URDF file\n    urdf_file_name = 'my_simple_robot.urdf'\n    urdf_path = os.path.join(\n        get_package_share_directory('my_robot_description'),\n        'urdf',\n        urdf_file_name\n    )\n\n    # Path to your world file\n    world_file_name = 'my_empty_world.world'\n    world_path = os.path.join(\n        get_package_share_directory('my_robot_simulation'),\n        'worlds',\n        world_file_name\n    )\n\n    # Declare the 'use_sim_time' argument for ROS 2 nodes\n    use_sim_time = LaunchConfiguration('use_sim_time', default='true')\n\n    # Start Gazebo\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([os.path.join(\n            get_package_share_directory('gazebo_ros'), 'launch', 'gazebo.launch.py')]),\n        launch_arguments={'world': world_path}.items(),\n    )\n\n    # Robot State Publisher node (from URDF chapter)\n    robot_state_publisher_node = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        output='screen',\n        parameters=[{'robot_description': urdf_path, 'use_sim_time': use_sim_time}],\n    )\n\n    # Joint State Publisher node (if simulating joint states)\n    joint_state_publisher_node = Node(\n        package='joint_state_publisher_gui',\n        executable='joint_state_publisher_gui',\n        name='joint_state_publisher_gui',\n        output='screen',\n        parameters=[{'use_sim_time': use_sim_time}],\n    )\n\n    # Spawn the robot into Gazebo\n    spawn_entity = Node(package='gazebo_ros', executable='spawn_entity.py',\n                        arguments=['-topic', 'robot_description',\n                                   '-entity', 'my_simple_robot',\n                                   '-x', '0.0', '-y', '0.0', '-z', '0.1'], # Initial pose\n                        output='screen')\n\n    return LaunchDescription([\n        DeclareLaunchArgument(\n            'use_sim_time',\n            default_value='true',\n            description='Use simulation (Gazebo) clock if true'),\n        gazebo,\n        robot_state_publisher_node,\n        joint_state_publisher_node,\n        spawn_entity,\n    ])\n"})}),"\n",(0,t.jsx)(n.h3,{id:"running-the-simulation",children:"Running the Simulation"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build your packages"}),": ",(0,t.jsx)(n.code,{children:"colcon build --packages-select my_robot_description my_robot_simulation"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Source the setup files"}),": ",(0,t.jsx)(n.code,{children:"source install/setup.bash"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Launch the simulation"}),": ",(0,t.jsx)(n.code,{children:"ros2 launch my_robot_simulation spawn_robot.launch.py"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This will open the Gazebo GUI with your custom world and your robot spawned at the specified coordinates. You can then interact with the robot in Gazebo, send commands via ROS 2 topics, and visualize sensor data, effectively working with your robot's digital twin."}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo is a cornerstone for robotics simulation, enabling the creation and interaction with digital twins. Its powerful physics engine, sensor simulation capabilities, and tight integration with ROS 2 make it an essential tool for developing, testing, and refining Physical AI and humanoid robotics algorithms in a safe and cost-effective virtual environment."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var o=i(6540);const t={},s=o.createContext(t);function a(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);